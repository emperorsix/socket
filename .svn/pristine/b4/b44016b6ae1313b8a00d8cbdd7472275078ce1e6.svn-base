package com.zhangxuan.net.socket.model;

import java.io.IOException;

public abstract class Frame {

	public static int MAX_FRAME_SIZE = 1024 * 1024;

	private String src;
	private String dst;
	private int id;

	private int writeIndex = 0;
	private int writeTotal = 0;
	private byte[] writeTemp = null;

	private int readIndex = 0;
	private int readTotal = 0;

	public String getSrc() {
		return src;
	}

	public void setSrc(String src) {
		this.src = src;
	}

	public String getDst() {
		return dst;
	}

	public void setDst(String dst) {
		this.dst = dst;
	}

	public int getId() {
		return id;
	}

	protected void setId(int id) {
		this.id = id;
	}

	public void write(byte[] bs) throws IOException {
		if (bs == null || bs.length == 0)
			return;
		if (bs.length > getWriteRemain())
			throw new IllegalArgumentException("The bytes length frame.write received is too big");
		int tmpsize = 0;
		if (writeTemp != null && writeTemp.length > 0) {
			tmpsize = writeTemp.length;
			int newsize = tmpsize + bs.length;
			byte[] tmp = new byte[newsize];
			System.arraycopy(writeTemp, 0, tmp, 0, writeTemp.length);
			System.arraycopy(bs, 0, tmp, writeTemp.length + 1, bs.length);
			writeTemp = tmp;
		} else {
			writeTemp = bs;
		}
		int wi = onWrite(writeTemp);
		writeIndex += wi;

		if (wi <= 0)
			return;
		int newsize = writeTemp.length - wi;
		if (newsize == 0) {
			writeTemp = null;
			return;
		}
		byte[] tmp = new byte[newsize];
		System.arraycopy(writeTemp, wi + 1, tmp, 0, newsize);
		writeTemp = tmp;
	}

	protected abstract int onWrite(byte[] bs) throws IOException;

	public abstract boolean startToWrite();

	public abstract boolean startToRead();

	public AckFrame replyFrame() {
		AckFrame ackFrame = new AckFrame();
		ackFrame.setDst(this.src);
		ackFrame.setDst(src);
		ackFrame.setId(this.id);
		return ackFrame;
	}

	public byte[] read(int size) throws IOException {
		if (size <= 0)
			throw new IllegalArgumentException("read size error");
		if (size + readIndex > readTotal)
			size = readTotal - readIndex;
		if (size <= 0)
			return null;
		byte[] bs = onRead(size);
		if (bs != null)
			readIndex += bs.length;
		return bs;
	}

	protected abstract byte[] onRead(int size) throws IOException;

	public int getWriteRemain() {
		return writeTotal - writeIndex;
	}

	public int getReadRemain() {
		return readTotal - readIndex;
	}

	// protected int getWriteTotal() {
	// return writeTotal;
	// }
	//
	// protected int getReadTotal() {
	// return readTotal;
	// }

	protected void setWriteTotal(int writeTotal) {
		this.writeTotal = writeTotal;
	}

	protected void setReadTotal(int readTotal) {
		this.readTotal = readTotal;
	}

	protected int getWriteIndex() {
		return writeIndex;
	}

	protected int getReadIndex() {
		return readIndex;
	}

	protected void setWriteIndex(int writeIndex) {
		this.writeIndex = writeIndex;
	}

	protected void setReadIndex(int readIndex) {
		this.readIndex = readIndex;
	}

	public static Frame createFrame(byte sign) {
		if ((sign & 0xf0) != 0xf0)
			return null;
		int ptc = sign & 0x0f;
		if (ptc == 0)
			return new AckFrame();
		else if (ptc == 1)
			return new PingFrame();
		else if (ptc == 2)
			return new BinaryFrame();
		else if (ptc == 3)
			return new TextFrame();
		else if (ptc == 15)
			return new CmdFrame();
		else
			return null;
	}

	public static byte getSign(Frame frame) {
		if (frame instanceof AckFrame)
			return (byte) 0xF0;
		else if (frame instanceof PingFrame)
			return (byte) 0xf1;
		else if (frame instanceof CmdFrame)
			return (byte) 0xff;
		else if (frame instanceof TextFrame)
			return (byte) 0xf3;
		else if (frame instanceof BinaryFrame)
			return (byte) 0xf2;
		else
			return 0x00;
	}
}
